# Chunking

## 청킹(Chunking)

chatGPT와 같은 언어모델은 입력 길이에 제한이 있다. 

정해진 입력 길이를 초과하면 문서를 한번에 처리할 수가 없다. 

입력 길이 제한 내의 텍스트라도 너무 길면 모델이 검토해야 할 정보량이 과다해져 답변의 정확도가 떨어 질 수 있다. 

RAG가 Chunking이 필요한 이유이다. 

텍스트를 잘라서 분할단위로 처리해야한다. 

### 1) 길이단위 청킹(RecursiveCharacterTextSplitter)

텍스트 분할 도구 중 가장 널리 사용 된다.

긴 텍스트를 입력받아 특정 규칙에 따라 반복적으로 분할하여 더 짧은 단위의 텍스트로 만든다. 

사용자는 각 청크의 최대 길이를 지정할 수 있다. 

분할기는 `[”\n\n”, ”\n”, ” “, ””]`총 4개의 문자를 기준으로 사용한다. 

### 1) 동작방식

1. `\n\n(두번의 줄바꿈)`을 기준으로 텍스트를 나눈다. 
2. 나눈 청크가 여전히 원하는 길이보다 크다면 \n(한번의 줄바꿈)을 기준으로 다시 나눈다. 
3. 그래도 지정된 크기를 초과한다면 `“ “(공백)`을 사용하여 나누는 작업을 반복한다. 

이 과정을 통해 텍스트를 점진적으로 더 작은 단위로 분할하여, 최종적으로 사용자가 원하는 크기에 근사한 청크를 얻는다. 

```jsx
**import** urllib.request
**from** langchain.text_splitter **import** RecursiveCharacterTextSplitter
urllib.request.urlretrieve("https://raw.githubusercontent.com/lovit/soynlp/master/tutorials/2016-10-20.txt", filename="2016-10-20.txt")
**with** open("2016-10-20.txt", encoding="utf-8") as f:
		file = f.read()
pprint('텍스트의 길이: ', len(file)). #결과: 길이: 18085369
```

### 2) RecursiveCharacterTextSplitter사용하기

text_splitter 객체 만들기 

chunk_size 값을 500으로 지정

chunk_overlap은 텍스트를 분할할 때 각 청크가 내용을 얼만큼 겹치게 할 것인지를 정하는 값으로 0으로 지정하면 내용이 겹치지 않는다. 

```jsx
text_splitter = RecursiveCharacterTextSplitter(chunk_size=500, chunk_overlap=0)
texts = text_splitter.create_documents)[file])
print('분할된 청크의 수:' len(texts)) # 출력: 47068
```

1번 인덱스 청크 출력하여 결과 확인하기 

```jsx
texts[1] 
# 출력: Document(page_content='오패산터널 총격전 용의자 검거 서울 연합뉴스 경찰 관계자들이 19일 오후 서울 강북구 오패산 터널 인근에서 사제 총기를 발사해 경찰을 살해한 용의자 성모씨를 검거하고 있다 성씨는 검거 당시 서바이벌 게임에서 쓰는 방탄조끼에 헬멧까지 착용한 상태였다 독자제공 영상 캡처 연합뉴스  서울 연합뉴스 김은경 기자 사제 총기로 경찰을 살해한 범인 성모 46 씨는 주도면밀했다  경찰에 따르면 성씨는 19일 오후 강북경찰서 인근 부동산 업소 밖에서 부동산업자 이모 67 씨가 나오기를 기다렸다 이씨와는 평소에도 말다툼을 자주 한 것으로 알려졌다  이씨가 나와 걷기 시작하자 성씨는 따라가면서 미리 준비해온 사제 총기를 이씨에게 발사했다 총알이 빗나가면서 이씨는 도망갔다 그 빗나간 총알은 지나가던 행인 71 씨의 배를 스쳤다  성씨는 강북서 인근 치킨집까지 이씨 뒤를 쫓으며 실랑이하다 쓰러뜨린 후 총기와 함께 가져온 망치로 이씨 머리를 때렸다  이 과정에서 오후 6시 20분께 강북구 번동 길 위에서')
```

Document(page_content="텍스트")의 형태의 결과가 출력된다. 

이 형태는 랭체인을 이용하여 텍스트를 다수의 청크로 분할했을 때 갖는 형태다. 

원문에 접근하려면 각 청크에 `texts[1] .page-content`를 붙여서 출력하면 된다. 

### 3) chunk_overlap

chunk_overlap의 값을 50으로 변경하여 text_splitter를 다시 선언하고 create_documents()를 사용하여 다수의 청크로 분할하기 

```jsx
text_splitter = RecursiveCharacterTextSplitter(chunk_size=500, chunk_overlap=50)
texts = text_splitter.create_documents([file])
print('분할된 청크의 수:', len(texts)) #출력: 48670
```

```jsx
texts[1].page_content
#출력: 오패산터널 총격전 용의자 검거 서울 연합뉴스 경찰 관계자들이 19일 오후 서울 강북구 오패산 터널 인근에서 사제 총기를 발사해 경찰을 살해한 용의자 성모씨를 검거하고 있다 성씨는 검거 당시 서바이벌 게임에서 쓰는 방탄조끼에 헬멧까지 착용한 상태였다 독자제공 영상 캡처 연합뉴스  서울 연합뉴스 김은경 기자 사제 총기로 경찰을 살해한 범인 성모 46 씨는 주도면밀했다  경찰에 따르면 성씨는 19일 오후 강북경찰서 인근 부동산 업소 밖에서 부동산업자 이모 67 씨가 나오기를 기다렸다 이씨와는 평소에도 말다툼을 자주 한 것으로 알려졌다  이씨가 나와 걷기 시작하자 성씨는 따라가면서 미리 준비해온 사제 총기를 이씨에게 발사했다 총알이 빗나가면서 이씨는 도망갔다 그 빗나간 총알은 지나가던 행인 71 씨의 배를 스쳤다  성씨는 강북서 인근 치킨집까지 이씨 뒤를 쫓으며 실랑이하다 쓰러뜨린 후 총기와 함께 가져온 망치로 이씨 머리를 때렸다  이 과정에서 오후 6시 20분께 강북구 번동 길 위에서
```

```jsx
texts[2].page_content
#**출력: 망치로 이씨 머리를 때렸다  이 과정에서 오후 6시 20분께 강북구 번동 길 위에서** 사람들이 싸우고 있다 총소리가 났다 는 등의 신고가 여러건 들어왔다  5분 후에 성씨의 전자발찌가 훼손됐다는 신고가 보호관찰소 시스템을 통해 들어왔다 성범죄자로 전자발찌를 차고 있던 성씨는 부엌칼로 직접 자신의 발찌를 끊었다  용의자 소지 사제총기 2정 서울 연합뉴스 임헌정 기자 서울 시내에서 폭행 용의자가 현장 조사를 벌이던 경찰관에게 사제총기를 발사해 경찰관이 숨졌다 19일 오후 6시28분 강북구 번동에서 둔기로 맞았다 는 폭행 피해 신고가 접수돼 현장에서 조사하던 강북경찰서 번동파출소 소속 김모 54 경위가 폭행 용의자 성모 45 씨가 쏜 사제총기에 맞고 쓰러진 뒤 병원에 옮겨졌으나 숨졌다 사진은 용의자가 소지한 사제총기  신고를 받고 번동파출소에서 김창호 54 경위 등 경찰들이 오후 6시 29분께 현장으로 출동했다 성씨는 그사이 부동산 앞에 놓아뒀던 가방을 챙겨 오패산 쪽으로 도망간 후였다
```

**출력: “망치로 이씨 머리를 때렸다  이 과정에서 오후 6시 20분께 강북구 번동 길 위에서” 중복되는 부분 확인 가능** 

 RecursiveCharacterTextSplitter()를 통해 분할된 청크들을 보면 어떠한 문맥을 파악하여 문맥 단위로 분할하는 것이 아니라 기본적으로 길이에 맞추어 분할하므로 내용이 중간에 전개되다가 **갑자기 끊긴다는 느낌을 받을수 있다.**

빠른 분할 결과를 얻을 수는 있지만 내용의 **완결성이 없는 청크들로 인해 RAG챗봇 개발 시 완결성 없는 청크들이 입력으로 전달되어 챗봇의 성능저하 이슈를 발생 시킬 수 있다.**